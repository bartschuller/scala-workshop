First day of Scala
==================
:icons:
:corpname: Lunatech Labs
:language: scala
Bart Schuller <schuller@lunatech.com>
v. 0.1, 2011-09-11

== Today's menu

* Introduction to the Scala language
* Scala tools and resources
* Setting up your environment
* Excercises

Actually, we're going the agile route and iterate these
subjects.

This workshop on github (please switch branch):

https://github.com/bartschuller/scala-workshop


== About

* what
* when
* who

=== What is Scala?

A programming language which is

* Statically typed
* Object Oriented
* Functional
* and more
* focus on concurrency

ifdef::backend-slidy2[<<<]

* Open Source
* runs on JVM
* is compiled
* has a REPL

=== History

Written by Martin Odersky, who also added generics to Java
and wrote the current java compiler.

* Design started in 2001
* first release in 2003
* 2.0 in 2006
* Current version is 2.9.1

Odersky is professor at EPFL in Switzerland, where Scala
releases come from.

=== Commercial backing

The company http://typesafe.com/[Typesafe] was founded in 2011 by Odersky and
others to promote and support Scala and the Akka middleware
framework.

Advisors

* James Gosling
* Doug Lea

Investors

* Greylock Partners
* founders of VMWare

== Language introduction

* general syntax
* val, var, def
* types

=== Values

Scala has expressions that look the same as in most other
languages. You can store the value of an expression like
this:

[source]
-----
val subtotal = 42.0
val tax = 1.19
val fees = 10
val total = subtotal*tax + fees

println("Please pay us €"+ total +" promptly.")
-----

=== Values are forever

A `val` never changes value once initialized, and
initialization has to happen at the declaration site.

[source]
val total = 42.0
total = total * 1.19 // <1>

<1> Compilation error

=== Variables, if you must

A `var` is like the variables from most other programming
languages (but not math!)

Scala programmers try to keep their use to a minimum.

[source]
var total = 42.0
total = total * 1.19

=== methods

A method or a function uses the `def` keyword:

[source]
---------------------
def sayit = println("it!")

def taxed(untaxed: Double) = untaxed * 1.19

val total = taxed(subtotal) + fees

def isEven(n: Int) = {
    if (n % 2 == 0)
        true
    else
        false
}
---------------------

Note the equals sign.

What else do you notice?

=== Types

Values, variables and return types have optional type
annotations.

[source]
-----------------------
val i = 10
val j: Int = 20
var k: String = _

def m: Unit = println("no return value")

def n { // <1>
    println("also Unit ('void' in java)")
}
-----------------------

<1> No equals sign means it's Unit

==== Built-in types and literals

Byte:: `1, -127`
Short:: `32767, 0xff, 0777`
Int:: `10, -46565`
Long:: `2744L, 5845776520L`
Boolean:: `true, false`

ifdef::backend-slidy2[<<<]

Float:: `0.01F, -1e8F`
Double:: `3.002, 34D`
Char:: `'a', '€'`
String:: `"Note the \"escapes\"",
  """multi-line, embedded "quotes""""`

==== Compound types

- Tuples
- Arrays
- Collections

===== Tuples

[source]
----------
def divide(a: Int, b: Int): (Int, Int) =
    (a / b, a % b)

val (result, remainder) = divide(72, 30)

val asl = (30, true, "Rotterdam")

println("Welcome to %s".format(asl._3))
----------

[NOTE]
====================
Even though you can make very flexible compound
types, the following will give a compile error because
each element still has a static type:

[source]
val halfsex = asl._2 / 2

_error: value / is not a member of Boolean_

====================

ifdef::backend-slidy2[<<<]

.Semicolons
************************
Scala _infers_ semicolons at the end of a line where that
line could validly end.

Problems can arise.

[source]
a = 1 + 1 + 1     // <1> don't do this
    + 1           // <2>
b = 1 + 1 + 1 +   // <3> do this
    1

:incremental:
<1> Statement looks finished at the end of the line, so
compiler infers a semicolon. *a == 3*
<2> New statement: throw away positive one
<3> End with an operator, the compiler will expect more and
continues looking at the next line. *b == 4*
************************
:incremental!:

===== Arrays

[source]
-----------------
val blob: Array[Byte] = fetchBlob
val first = blob(0)

def fetchBlob = Array[Byte](0, 1, 2, 3)
def newArray = new Array[String](10)
-----------------

===== Collections

We'll get to collections once we've covered what they're
made of: classes and objects.

But first, it's time t get our hands dirty.

== Installing the Tools

- [line-through]#scala#
- git
- sbt

=== Installing Scala

Recommendation: skip the standalone scala compiler, go
straight to the build tool.

`brew install scala [--with-docs]`

Install sbt instead.

==== SBT

- Simple Build Tool
- Downloads deps [small]#(a.k.a. the internet)#, builds, tests
- _Using_ it is simple
- https://github.com/harrah/xsbt/wiki/
- Watch out, 0.10/0.11 is latest, not compatible with 0.7 or
  earlier

==== Installing sbt

We use sbt 0.10.1 for this workshop.

Mac with HomeBrew:: `brew install sbt`
Everything else::
  Use `sbt` in the root of the workshop project from github and peruse
  https://github.com/harrah/xsbt/wiki/Setup at your leasure.

[small]#Optionally create `~/.sbtconfig`, mine contains +
`SBT_OPTS="-Dsbt.boot.directory=$HOME/.sbt/boot/` +
`-XX:+CMSClassUnloadingEnabled -server -Xss2m -Xms128m` +
`-Xmx1024m -XX:MaxPermSize=512M -Dfile.encoding=UTF-8"`#

==== Using sbt

Existing project (directory contains `build.sbt` and/or
`project/*.scala`):

- Open a terminal
- cd to the project directory
- type `sbt` (or `./sbt` for the workshop)

New project:

- Make empty project directory, cd to it
- `mkdir -p src/main/scala src/test/scala`
- Optionally copy and change this workshop's `build.sbt`

Other options include

- https://github.com/n8han/giter8[giter8]
- https://github.com/typesafehub/sbteclipse[sbteclipse]
  _create-src_ option
- https://github.com/softprops/np[np] sbt plugin

==== SBT commands

- `compile`
- `test`
- `run`
- `~test` -- keep testing while you make changes
- `console` -- finally a Scala REPL

==== Play time

Start the console and type some expressions. Try the TAB
completion. Define some functions.

Notice that every expression gets assigned to a new variable
name `res0` etc., so creating a `val` is optional.

If you want to paste larger snippets then start by typing
`:paste`, paste your code, then type __Ctrl__-D.

== Language Intro part 2

Building programs and libraries

=== Organizing code

- Classes
- Objects
- Traits
- Namespaces
- Case Classes

==== Classes

The bread and butter of every program.

[source]
----------------
class Person(val name: String, var address: Address) {
  var moved = false
  override def toString = "%s from %s".format(name,
                   address.municipality)
  def move(newAddress: Address) {
    address = newAddress
    moved = true
  }
}

class Address(val municipality: String, val country: String) {
    override def toString = "%s, %s".format(municipality,
                   country)
}
----------------

ifdef::backend-slidy2[<<<]

Using classes looks pretty familiar.

[source]
-----------------------------
val bart = new Person("Bart", new Address("Heemraadssingel 70",
                                       "Rotterdam", "Holland"))
println(bart)
bart.move(new Address("Oudemansstraat",
                      "Den Haag", "The Netherlands"))
println(bart)
-----------------------------

==== Objects

Mr. Singleton

[source]
----------------------------
object Person {
  private var peopleCount = 0
  def total = peopleCount
  def apply(name: String, address: Address) = {
    peopleCount += 1
    new Person(name, address)
  }

  def swapHomes(a: Person, b: Person) {
    val aHome = a.address
    a.address = b.address
    b.address = aHome
  }
}
----------------------------

ifdef::backend-slidy2[<<<]

Out with the new

[source]
----------------------------
val bart = Person("Bart", Address("Oudemansstraat",
                          "Den Haag", "The Netherlands"))
val paco = Person("Francisco", Address("Zuid",
                               "Rotterdam", "Holland"))
Person.total should_== 2
Person.swapHomes(bart, paco)
bart.address.municipality should_== "Rotterdam"
----------------------------

ifdef::backend-slidy2[<<<]

I almost forgot

[source]
----------------------------
object MainProgram {
  def main(args: Array[String]) {
    println("Hello, world!")
  }
}
----------------------------

Or shorter

[source]
----------------------------
object HelloWorld extends App {
  println("Hello, world!")
}
----------------------------

==== Traits

[source]
----------------------------
trait Named {
  def name: String
}

trait Ordered[A] {
  def compare(that: A): Int
}

class Person(val name: String) extends
		Named with Ordered[Person] {
  def compare(that: Person) = name.compare(that.name)
}
----------------------------

ifdef::backend-slidy2[<<<]

[source]
----------------------------
var n: Named = new Person("Bart")

n = new Named { def name = "name " + math.random }
n = new Named { val name = "Bart" }
----------------------------

ifdef::backend-slidy2[<<<]

- Traits can include concrete methods
- Create mixin types on the spot

[source]
----------------------------
trait Damned extends Named {
  def damned = name.reverse
}

val bart = new Person with Damned
bart.damned
----------------------------

==== Packages and visibility

- packages
- imports
- privacy

ifdef::backend-slidy2[<<<]

- import whatever
- wherever

[source]
----------------------------
package com.lunatech.helloworld

import com.lunatech.handy._

object Hello extends App {
  Handy.foo()

  import Handy._
  foo()
}
----------------------------

ifdef::backend-slidy2[<<<]

- default is public
- ultra-privacy is available

[source]
----------------------------
package com.lunatech.foo

class Foo(private var i: Int) {
  private[this] val orig = i
  protected def printOrig = println(orig)
  def otherI(o: Foo) = o.i

  // error: value orig is not a member of Foo
  def otherOrig(o: Foo) = o.orig
}
----------------------------

[source]
----------------------------
val foo = new Foo(7) { def gimme = printOrig }
foo.gimme
----------------------------

==== Case Classes

[source]
----------------------------
case class Person(name: String, address: Address)
case class Address(municipality: String, country: String)

val bart1 = Person("Bart", Address(
                     "Den Haag", "The Netherlands"))
val bart2 = bart.copy(address = Address(
                              "Rotterdam", "Holland"))
----------------------------

== Installing more Tools

- IntelliJ
- or Eclipse
- Scala plugin
- sbt plugin for generating intellij/eclipse files

=== IntelliJ IDEA

- Community Edition from http://www.jetbrains.com/idea/


=== Collections

- List
- Vector
- Option
- Map

== For loops

[source]
for (i <- 1 to 10) { println(i) }


== Euler problem 9

A Pythagorean triplet is a set of three natural numbers, +
a < b < c, for which,

[center]_a^2^ + b^2^ = c^2^_

For example, 3^2^ + 4^2^ = 9 + 16 = 25 = 5^2^.

There exists exactly one Pythagorean triplet for which +
a + b + c = 1000. Find the product _abc_.

== Analysis

All are Natural numbers, so > 0 +
a < b < c +
a^2^ + b^2^ = c^2^ +
a + b + c = 1000

* a, b and c are smaller than 1000
* c = 1000 - a - b
* let's just try all a and b below 1000

== for

[source]
  def euler9 = {
    val ans =
      for (b <- 2 to 1000;  // <1>
           a <- 1 to b;     // <2>
           c = 1000 - a - b
               if c*c == a*a + b*b)
        yield a*b*c
    ans.head
  }

<1> _b_ is a fresh variable, taking on the succesive
values 2 to 1000 inclusive
<2> This is a loop within a loop, _a_ loops from 1 to the
current value of b, so we generate all possible combinations
of a and b.

== for

[source]
  def euler9 = {
    val ans =
      for (b <- 2 to 1000;
           a <- 1 to b;
           c = 1000 - a - b // <1>
               if c*c == a*a + b*b) // <2>
        yield a*b*c
    ans.head
  }

<1> Assignment just gives a name to an expression, we still
loop just over b, then a.
<2> An `if` statement can appear anywhere to add a
constraint to the combination of values. If not met, then inner loops and the
body are skipped.

== Observer pattern

Java has had `java.util.Observable` since 1.0, but
it's never used

* No generics (fixable)
* It's a class (can't mix it in)

== Last slide

That's all, folks!

== Topics discussed

[role="handout"]
*******
We'll not have endless slides explaining what Scala is or
the many ways it's awesome.

Today, you'll just _use_ it and see it used.
*******

== Topics yet to write

* Why Scala?
** Short history
** Overview of Scala's core characteristics
* Setting up the development environment
** Installing the Scala distribution
** Installing Eclipse and the Scala plugin
** Installing sbt
* First steps
** Interactive programming in the REPL
** Variables and methods
** Expressions and type inference
** First glance at functions
* Basic OO features
** Classes, class parameters, constructors
** Fields, class parameters as fields
** Methods
** Operators
** Named and default arguments
** Packages and imports
** Access modifiers
** Singleton objects, companions, Predef
** Case classes
* Testing in Scala
** SBT managed dependencies
** Test-driven development with triggered test (\~test)
** Testing with specs2
* Learning FP by collections
** Collection hierarchy, creating instances
** Type parameters
** Tuples
** Immutability versus mutability
** Some important collection methods
** Higher-order functions and function literals
** Functions values, function types, short notation
** Important higher order functions: map, flatMap and filter
* For-expressions and -loops
** Generators
** Filters
** Definitions
** Translation of for-expressions and -loops
* Inheritance and traits
** Extending classes
** Final and sealed classes
** Enumerations
** Overriding members
** Abstract classes
** Implementing abstract members
** Standard type hierarchy
** Traits and mix-in composition
* Pattern Matching
** Match-expressions
** Pattern types
** Pattern guards
** Patterns outside of match expressions
* XML support
** Built-in literals
** XML library


// a2x: --dblatex-opt "-i /Users/schuller/texmf/tex// -P latex.encoding=utf8 -P latex.output.revhistory=0 -P doc.collab.show=1"
// vim:tw=60:
