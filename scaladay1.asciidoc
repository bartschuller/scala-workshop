First day of Scala
==================
:icons:
:corpname: Lunatech Labs
:language: scala
Bart Schuller <schuller@lunatech.com>
v. 0.1, 2011-09-11

== Today's menu

* Introduction to the Scala language
* Scala tools and resources
* Setting up your environment
* Excercises

Actually, we're going the agile route and iterate these
subjects.

== About

* what
* when
* who

=== What is Scala?

A programming language which is

* Statically typed
* Object Oriented
* Functional
* and more
* focus on concurrency

ifdef::backend-slidy2[<<<]

* Open Source
* runs on JVM
* is compiled
* has a REPL

=== History

Written by Martin Odersky, who also added generics to Java
and wrote the current java compiler.

* Design started in 2001
* first release in 2003
* 2.0 in 2006
* Current version is 2.9.1

Odersky is professor at EPFL in Switzerland, where Scala
releases come from.

=== Commercial backing

The company http://typesafe.com/[Typesafe] was founded in 2011 by Odersky and
others to promote and support Scala and the Akka middleware
framework.

Advisors

* James Gosling
* Doug Lea

Investors

* Greylock Partners
* founders of VMWare

== Language introduction

* general syntax
* val, var, def
* types

=== Values

Scala has expressions that look the same as in most other
languages. You can store the value of an expression like
this:

[source]
-----
val subtotal = 42.0
val tax = 1.19
val fees = 10
val total = subtotal*tax + fees

println("Please pay us €"+ total +" promptly.")
-----

=== Values are forever

A `val` never changes value once initialized, and
initialization has to happen at the declaration site.

[source]
val total = 42.0
total = total * 1.19 // <1>

<1> Compilation error

=== Variables, if you must

A `var` is like the variables from most other programming
languages (but not math!)

Scala programmers try to keep their use to a minimum.

[source]
var total = 42.0
total = total * 1.19

=== methods

A method or a function uses the `def` keyword:

[source]
---------------------
def sayit = println("it!")

def taxed(untaxed: Double) = untaxed * 1.19

val total = taxed(subtotal) + fees

def isEven(n: Int) = {
    if (n % 2 == 0)
        true
    else
        false
}
---------------------

Note the equals sign.

What else do you notice?

=== Types

Values, variables and return types have optional type
annotations.

[source]
-----------------------
val i = 10
val j: Int = 20
var k: String = _

def m: Unit = println("no return value")

def n { // <1>
    println("also Unit ('void' in java)")
}
-----------------------

<1> No equals sign means it's Unit

==== Built-in types and literals

Byte:: `1, -127`
Short:: `32767, 0xff, 0777`
Int:: `10, -46565`
Long:: `2744L, 5845776520L`
Boolean:: `true, false`

ifdef::backend-slidy2[<<<]

Float:: `0.01F, -1e8F`
Double:: `3.002, 34D`
Char:: `'a', '€'`
String:: `"Note the \"escapes\"",
  """multi-line, embedded "quotes""""`

==== Compound types

- Tuples
- Arrays
- Collections

===== Tuples

[source]
----------
def divide(a: Int, b: Int): (Int, Int) =
    (a / b, a % b)

val (result, remainder) = divide(72, 30)

val asl = (30, true, "Rotterdam")

println("Welcome to %s".format(asl._3))
----------

[NOTE]
====================
Even though you can make very flexible compound
types, the following will give a compile error because
each element still has a static type:

[source]
val halfsex = asl._2 / 2

_error: value / is not a member of Boolean_

====================

ifdef::backend-slidy2[<<<]

.Semicolons
************************
Scala _infers_ semicolons at the end of a line where that
line could validly end.

Problems can arise.

[source]
a = 1 + 1 + 1     // <1> don't do this
    + 1           // <2>
b = 1 + 1 + 1 +   // <3> do this
    1

:incremental:
<1> Statement looks finished at the end of the line, so
compiler infers a semicolon. *a == 3*
<2> New statement: throw away positive one
<3> End with an operator, the compiler will expect more and
continues looking at the next line. *b == 4*
************************
:incremental!:

===== Arrays

[source]
-----------------
val blob: Array[Byte] = fetchBlob
val first = blob(0)

def fetchBlob = Array[Byte](0, 1, 2, 3)
def newArray = new Array[String](10)
-----------------

== Installing Scala

`brew install scala [--with-docs]`

== For loops

[source]
for (i <- 1 to 10) { println(i) }


== Euler problem 9

A Pythagorean triplet is a set of three natural numbers, +
a < b < c, for which,

[center]_a^2^ + b^2^ = c^2^_

For example, 3^2^ + 4^2^ = 9 + 16 = 25 = 5^2^.

There exists exactly one Pythagorean triplet for which +
a + b + c = 1000. Find the product _abc_.

== Analysis

All are Natural numbers, so > 0 +
a < b < c +
a^2^ + b^2^ = c^2^ +
a + b + c = 1000

* a, b and c are smaller than 1000
* c = 1000 - a - b
* let's just try all a and b below 1000

== for

[source]
  def euler9 = {
    val ans =
      for (b <- 2 to 1000;  // <1>
           a <- 1 to b;     // <2>
           c = 1000 - a - b
               if c*c == a*a + b*b)
        yield a*b*c
    ans.head
  }

<1> _b_ is a fresh variable, taking on the succesive
values 2 to 1000 inclusive
<2> This is a loop within a loop, _a_ loops from 1 to the
current value of b, so we generate all possible combinations
of a and b.

== for

[source]
  def euler9 = {
    val ans =
      for (b <- 2 to 1000;
           a <- 1 to b;
           c = 1000 - a - b // <1>
               if c*c == a*a + b*b) // <2>
        yield a*b*c
    ans.head
  }

<1> Assignment just gives a name to an expression, we still
loop just over b, then a.
<2> An `if` statement can appear anywhere to add a
constraint to the combination of values. If not met, then inner loops and the
body are skipped.

== Observer pattern

Java has had `java.util.Observable` since 1.0, but
it's never used

* No generics (fixable)
* It's a class (can't mix it in)

== Last slide

That's all, folks!

== Topics discussed

[role="handout"]
*******
We'll not have endless slides explaining what Scala is or
the many ways it's awesome.

Today, you'll just _use_ it and see it used.
*******

== Topics yet to write

* Why Scala?
** Short history
** Overview of Scala's core characteristics
* Setting up the development environment
** Installing the Scala distribution
** Installing Eclipse and the Scala plugin
** Installing sbt
* First steps
** Interactive programming in the REPL
** Variables and methods
** Expressions and type inference
** First glance at functions
* Basic OO features
** Classes, class parameters, constructors
** Fields, class parameters as fields
** Methods
** Operators
** Named and default arguments
** Packages and imports
** Access modifiers
** Singleton objects, companions, Predef
** Case classes
* Testing in Scala
** SBT managed dependencies
** Test-driven development with triggered test (\~test)
** Testing with specs2
* Learning FP by collections
** Collection hierarchy, creating instances
** Type parameters
** Tuples
** Immutability versus mutability
** Some important collection methods
** Higher-order functions and function literals
** Functions values, function types, short notation
** Important higher order functions: map, flatMap and filter
* For-expressions and -loops
** Generators
** Filters
** Definitions
** Translation of for-expressions and -loops
* Inheritance and traits
** Extending classes
** Final and sealed classes
** Enumerations
** Overriding members
** Abstract classes
** Implementing abstract members
** Standard type hierarchy
** Traits and mix-in composition
* Pattern Matching
** Match-expressions
** Pattern types
** Pattern guards
** Patterns outside of match expressions
* XML support
** Built-in literals
** XML library


// a2x: --dblatex-opt "-i /Users/schuller/texmf/tex// -P latex.encoding=utf8 -P latex.output.revhistory=0 -P doc.collab.show=1"
// vim:tw=60:
